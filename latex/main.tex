\documentclass[a4paper,UKenglish]{lipics-v2016}
% for section-numbered lemmas etc., use "numberwithinsect"
 
\usepackage{microtype}%if unwanted, comment out or use option "draft"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{A Normalizing Computation Rule for Propositional Extensionality in Higher-Order Minimal Logic
%\footnote{This work was partially supported by someone.}
}
\titlerunning{Strong Normalization for Propositional Extensionality in Minimal Logic} %optional, in case that the title is too long; the running title should fit into the top page column

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\author[1]{Robin Adams}
\author[1]{Marc Bezem}
\author[3]{Thierry Coquand}
\affil[1]{Universitetet i Bergen, Institutt for Informatikk, Postboks 7800, N-5020 BERGEN, Norway \\
  \texttt{\{robin.adams,bezem\}@ii.uib.no}}
\affil[3]{Chalmers tekniska högskola, Data- och informationsteknik, 412 96 Göteborg, Sweden \\
  \texttt{coquand@chalmers.se}}
\authorrunning{R. Adams, M. Bezem and T. Coquand} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{Robin Adams and Marc Bezem and Thierry Coquand}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{Dummy classification -- please refer to \url{http://www.acm.org/about/class/ccs98-html}}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
\keywords{Dummy keyword -- please provide 1--5 keywords}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{suffix}
\newcommand*{\eqdef}{\mathrel{\smash{\stackrel{\text{def}}{=}}}}
\newcommand*{\isotoid}{\ensuremath{\mathrm{isotoid}}}
\newcommand*{\reff}[1]{\ensuremath{\mathrm{ref} \left( {#1} \right)}}
\newcommand*{\univ}[4]{\ensuremath{\mathrm{univ}_{{#1}, {#2}} \left({#3} , {#4} \right)}}
\WithSuffix\newcommand\univ*[2]{\ensuremath{\mathsf{univ} \left( {#1} , {#2} \right)}}
\newcommand*{\triplelambda}{\ensuremath{\lambda \!\! \lambda \!\! \lambda}}
\newcommand*{\vald}{\ensuremath{\vdash \mathrm{valid}}}
\newcommand*{\dom}{\ensuremath{\operatorname{dom}}}
\newcommand{\Path}[3]{\ensuremath{\mathrm{Path} \, {#1} \, {#2} \, {#3}}}
\newcommand{\nf}{\ensuremath{\ \mathrm{nf}}}
\newcommand{\Prop}{\mathbf{Prop}}
\newcommand{\outputt}{\mathrm{output}}
\newcommand{\isProp}[1]{\mathrm{isProp} \left( {#1} \right)}
\newcommand{\mapid}[2]{\mathrm{mapid}_{#1} \, {#2}}
\newcommand{\comp}{\mathrm{comp}}

\theoremstyle{plain}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
\newtheorem{note}[theorem]{Note}

\usepackage{proof}

\begin{document}

\maketitle

\begin{abstract}
The univalence axiom expresses the principle of extensionality for dependent types theory. However, if we simply add the univalence axiom to type theory, then we lose the property of canonicity --- that every term computes to a normal form. A computation becomes `stuck' when it reaches the point that it needs to evaluate a proof term that is an application of the univalence axiom. So we wish to find a way to compute with the univalence axiom. While this problem has been solved with the formulation of cubical type theory, where the computations are expressed using a nominal extension of lambda-calculus, it may be interesting to explore alternative solutions, which do not require such an extension.

As a first step, we present here a system of higher-order minimal propositional logic, with a universe $\Omega$ of propositions closed under implication. We add a type $M =_A N$ for any terms $M$, $N$ of type $A$, and two ways to prove an equality: reflexivity, and \emph{propositional extensionality} --- logically equivalent propositions are equal.  This system allows for some definitional equalities that are not present in cubical type theory, namely that transport along the trivial path is identity.

We present a call-by-need reduction relation for this system, and prove that the system satisfies canonicity: every closed typable term head-reduces to a canonical form.  This work has been formalised in Agda.
 \end{abstract}

%\item Fill out the \verb+\subjclass+ and \verb+\keywords+ macros. For the \verb+\subjclass+, please refer to the ACM classification at \url{http://www.acm.org/about/class/ccs98-html}.
%\item Take care of suitable linebreaks and pagebreaks. No overfull \verb+\hboxes+ should occur in the warnings log.

\section{Introduction}

The rules of deduction of a type theory are traditionally justified by a \emph{meaning explanation} \cite{ML:ITT}, in which to know that a given term has a given type is to know that it computes to a \emph{canonical object} of that type.  A necessary condition for such a meaning explanation is that the type theory should have the following syntactic properties:
\begin{itemize}
\item \textbf{Confluence} --- The reduction relation should be confluent.
\item \textbf{Normalization} --- Every well-typed term should reduce to a normal form.
\item Every closed normal form of type $A$ is a canonical object of type $A$.
\end{itemize}
From these three properties, we have:
\begin{itemize}
\item \textbf{Canonicity} --- Every closed term of type $A$ reduces to a unique canonical object of type $A$.
\end{itemize}

It is desirable to have, in addition, \emph{strong normalization}, so that we know that we are free to choose whatever reduction strategy we please.

The \emph{univalence axiom} of Homotopy Type theory (HoTT) \cite{hottbook} breaks the property of canonicity.  It postulates a
constant
\[ \isotoid : A \simeq B \rightarrow A = B \]
that is an inverse to the canonical function $A = B \rightarrow A \simeq B$.  When a computation reaches a point
where we eliminate a path (proof of equality) formed by $\isotoid$, it gets 'stuck'.

As possible solutions to this problem, we may try to do with a weaker property than canonicity, such as \emph{propositional canonicity}.
We may attempt to prove that every closed term of type $\mathbb{N}$ is \emph{propositionally} equal to a numeral, as conjectured by Voevodsky.  Or we may attempt to change the definition of equality to make $\isotoid$ definable \cite{Polonsky14a}, or extend the type theory with higher dimensions (e.g. Cubical Type Theory \cite{cchm:cubical}).

We could also try a more conservative approach, and simply attempt to find a reduction relation for a type theory involving $\isotoid$ that satisfies
all three of the properties above.  There seems to be no reason \emph{a priori} to believe this is not possible, but it is difficult to do because
the full Homotopy Type Theory is a complex and interdependent system.  We can tackle the problem by adding univalence to a much simpler system, finding
a well-behaved reduction relation, then doing the same for more and more complex systems, gradually approaching the full strength of HoTT.

In this paper, we present a system we call PHOML, or predicative higher-order minimal logic.  It is a type theory with two universes: the universe $\Omega$
of \emph{propositions}, and the universe of \emph{types}.  The propositions are closed under $\supset$ (implication) and include $\bot$ (falsehood), and an equality proposition $M =_A N$ for
any type $A$ and terms $M : A$ and $N : A$.  The types include $\Omega$ itself and are closed under $\rightarrow$ (non-dependent function type).

There are two canonical forms for proofs of $M =_\Omega N$.  For any term $M : \Omega$, we have $\reff{M} : M =_\Omega M$.  We also add univalence for this system, in this form:
if $\delta : \varphi \supset \psi$ and $\epsilon : \psi \supset\varphi$, then $\univ{\varphi}{\psi}{\delta}{\epsilon} : \varphi =_\Omega \psi$.  

In PHOML, propositions are equal if and only if they are logically equivalent.  Every function of type $\Omega \rightarrow \Omega$ that can be constructed in PHOML must therefore respect logical equivalence.  That is,
if $F, G : \Omega \rightarrow \Omega$ and $F x$ is logically equivalent to $G x$ (where $x : \Omega$ is a variable), then $F =_{\Omega \rightarrow \Omega} G$.  Every function of type $(\Omega \rightarrow \Omega) \rightarrow \Omega$ must respect this equivalence relation; and so on.  This is the manifestation in PHOML of the principle that only homotopy invariant constructions can be performed in homotopy type theory.  (See Section \ref{section:exampletwo}.)

We present a deterministic call-by-need reduction relation for this system, and prove that every typable term reduces to a canonical form.  From this, it follows that the system is consistent.  In the appendix, we present a proof of strong normalization for a different reduction relation.
%confluence (Corollary \ref{cor:confluence}), strong normalization (Corollary \ref{cor:SN}) and canonicity (Corollary \ref{cor:canon}).

For the future, we wish to expand the system with universal quantification, and expand it to a 2-dimensional system (with equations between proofs).

Another system with many of the same aims is cubical type theory \cite{cchm:cubical}.  The system PHOML is almost a subsystem of cubical type theory.  We can attempt to embed PHOML into cubical type theory,
mapping $\Omega$ to the universe $U$, and an equation $M =_A N$ to either the type $\Path{A}{M}{N}$ or to $\mathrm{Id}\ A\ M\ N$.  However, PHOML has more definitional equalities than the relevant fragment of cubical type theory; that is, there are definitionally equal terms in PHOML that are mapped to terms that are not definitionally equal in cubical type theory.  In particular, $\reff{x}^+ p$ and $p$ are definitionally equal, whereas the terms $\mathrm{comp}^i x [] p$ and $p$ are not definitionally equal in cubical type theory (but they are propositionally equal).  See Section \ref{section:cubical} for more information.

The proofs in this paper have been formalized in Agda.  The formalization is available at \texttt{github.com/radams78/univalence}.

\section{Predicative Higher-Order Minimal Logic with Extensional Equality}

We call the following type theory PHOML, or \emph{predicative higher-order minimal logic with extensional equality}.  

\subsection{Syntax}

Fix three disjoint, infinite sets of variables, which we shall call \emph{term variables}, \emph{proof variables}
and \emph{path variables}.  We shall use $x$ and $y$ as term variables, $p$ and $q$ as proof variables,
$e$ as a path variable, and $z$ for a variable that may come from any of these three sets.

The syntax of PHOML is given by the grammar:

\[
\begin{array}{lrcl}
\text{Type} & A,B,C & ::= & \Omega \mid A \rightarrow B \\
\text{Term} & L,M,N, \varphi,\psi,\chi & ::= & x \mid \bot \mid \varphi \supset \psi \mid \lambda x:A.M \mid MN \\
\text{Proof} & \delta, \epsilon & ::= & p \mid \lambda p:\varphi.\delta \mid \delta \epsilon \mid P^+ \mid P^- \\
\text{Path} & P, Q & ::= & e \mid \reff{M} \mid P \supset^* Q \mid \univ{\varphi}{\psi}{P}{Q} \mid \\
& & & \triplelambda e : x =_A y. P \mid P_{MN} Q \\
\text{Context} & \Gamma, \Delta, \Theta & ::= & \langle \rangle \mid \Gamma, x : A \mid \Gamma, p : \varphi \mid \Gamma, e : M =_A N \\
\text{Judgement} & \mathbf{J} & ::= & \Gamma \vald \mid \Gamma \vdash M : A \mid \Gamma \vdash \delta : \varphi \mid \\
& & & \Gamma \vdash P : M =_A N
\end{array}
\]

In the path $\triplelambda e : x =_A y . P$, the term variables $x$ and $y$ must be distinct.  (We also have $x \not\equiv e \not\equiv y$, thanks to our
stipulation that term variables and path variables are disjoint.)  The term variable $x$ is bound within $M$ in the term $\lambda x:A.M$,
and the proof variable $p$ is bound within $\delta$ in $\lambda p:\varphi.\delta$.  The three variables $e$, $x$ and $y$ are bound within $P$ in the path
$\triplelambda e:x =_A y.P$.  We identify terms, proofs and paths up to $\alpha$-conversion.  We write $E[z:=F]$ for the result of substituting $F$ for $z$ within
$E$, using $\alpha$-conversion to avoid variable capture.

We shall use the word 'expression' to mean either a type, term, proof, path, or equation (an equation having the form $M =_A N$).  We shall use $r$, $s$, $t$, $S$ and $T$ as metavariables that range over expressions.

Note that we use both Roman letters $M$, $N$ and Greek letters $\varphi$, $\psi$, $\chi$ to range over terms.  Intuitively, a term is understood as either a proposition or a function,
and we shall use Greek letters for terms that are intended to be propositions.  Formally, there is no significance to which letter we choose.

Note also that the types of PHOML are just the simple types over $\Omega$; therefore, no variable can occur in a type.

The intuition behind the new expressions is as follows (see also the rules of deduction in Figure \ref{fig:lambdaoe}).  For any object $M : A$, there is the trivial path $\reff{M} : M =_A M$.  The constructor $\supset^*$ ensures congruence for $\supset$ --- if $P : \varphi =_\Omega \varphi'$ and $Q : \psi =_\Omega \psi'$ then $P \supset^* Q : \varphi \supset \psi =_\Omega \varphi' \supset \psi'$.  The constructor $\mathsf{univ}$ gives univalence for our propositions: if $\delta : \varphi \supset \psi$ and $\epsilon : \psi \supset \varphi$, then $\univ{\varphi}{\psi}{\delta}{\epsilon}$ is a path of type $\varphi =_\Omega \psi$.  The constructors $^+$ and $^-$ are the converses: if $P$ is a path of type $\varphi =_\Omega \psi$, then $P^+$ is a proof of $\varphi \supset \psi$, and $P^-$ is a proof of $\psi \supset \varphi$.

The constructor $\triplelambda$ gives functional extensionality.  Let $F$ and $G$ be functions of type $A \rightarrow B$.  If $F x =_B G y$ whenever $x =_A y$, then $F =_{A \rightarrow B} G$.  More formally, if $P$ is a path of type $Fx =_B Gy$ that depends on $x : A$, $y : A$ and $e : x =_A y$, then $\triplelambda e : x =_A y . P$ is a path of type $F =_{A \rightarrow B} G$.  The proofs $P^+$ and $P^-$ represent transport along the path $P$.

Finally, if $P$ is a path of type $F =_{A \rightarrow B} G$, and $Q$ is a path $M =_A N$, then $P_{MN} Q$ is a path $FM =_B G N$.

\subsubsection{Substitution and Path Substitution}

Intuitively, if $N$ and $N'$ are equal then $M[x:=N]$ and $M[x:=N']$ should be equal.  To handle this syntactically,
we introduce a notion of \emph{path substitution}.  If $N$, $M$ and $M'$ are terms, $x$ a term variable, and $P$ a path, then we shall define a path $N \{ x := P : M = M' \}$.  The intention is that, if
$\Gamma \vdash P : M =_A M'$ and $\Gamma, x : A \vdash N : B$ then $\Gamma \vdash N \{ x := P : M = M' \} : N [ x:= M ] =_B N [ x := M' ]$ (see Lemma \ref{lm:pathsub}). 

\begin{definition}[Path Substitution]
Given terms $M_1$, \ldots, $M_n$ and $N_1$, \ldots, $N_n$; paths $P_1$, \ldots, $P_n$; term variables $x_1$, \ldots, $x_n$; and a term $L$, define the path $L \{ x_1 := P_1 : M_1 = N_1 , \ldots, x_n := P_n : M_n = N_n \}$ as follows.
\begin{align*}
x_i \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} \} & \eqdef P_i \\
y \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} \} & \eqdef \reff{y} \qquad (y \not\equiv x_1, \ldots, x_n) \\
\bot \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} \} & \eqdef \reff{\bot} \\
(LL') \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} \} \\
\omit\rlap{\qquad \qquad $\eqdef L \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} \}_{L' [\vec{x} := \vec{M}] L' [\vec{x} := \vec{N}]} L' \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} \}$} \\
(\lambda y:A.L) \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} \} & \\
\omit\rlap{\qquad\qquad $\eqdef \triplelambda e : a =_A a' . L \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} , y := e : a = a' \}$} \\
(\varphi \supset \psi) \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} \} & \eqdef \varphi \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} \} \supset^* \psi \{ \vec{x} := \vec{P} : \vec{M} = \vec{N} \}
\end{align*}
\end{definition}

We shall often omit the endpoints $\vec{M}$ and $\vec{N}$.

\begin{note}
The case $n = 0$ is permitted, and we shall have that, if $\Gamma \vdash M : A$ then $\Gamma \vdash M \{\} : M =_A M$.  There are thus two paths from a term $M$ to itself: $\reff{M}$ and $M \{\}$.  There are not always equal; for example, $(\lambda x:A.x) \{\} \equiv \triplelambda e : x =_A y. e$, which (after we define the reduction relation) will not be convertible with $\reff{\lambda x:A.x}$.
\end{note}

The following lemma shows how substitution and path substitution interact.

\begin{lemma}
\label{lm:subpathsub}
Let $\vec{y}$ be a sequences of variables and $x$ a distinct variable.  Then
\begin{enumerate}
\label{lm:pathsubsub}
\item
\label{lm:subpathsubi}
$ \begin{aligned}[t]
& M [ x:= N ] \{ \vec{y} := \vec{P} : \vec{L} = \vec{L'} \} \\
& \equiv M \{ x := N \{ \vec{y} := \vec{P} : \vec{L} = \vec{L'} \} : N [ \vec{y}:= \vec{L} ] = N [ \vec{y} := \vec{L'} ], \vec{y} := \vec{P} : \vec{L} = \vec{L'} \}
\end{aligned} $
\item
\label{lm:subpathsubii}
$ \begin{aligned}[t]
& M \{ \vec{y} := \vec{P} : \vec{L} = \vec{L'} \} [ x := N ] \\
& \equiv M \{ \vec{y} := \vec{P} [x := N] : \vec{L} [x := N] = \vec{L'} [x := N], x := \reff{N} : N = N \}
\end{aligned} $
\end{enumerate}
\end{lemma}

\begin{proof}
An easy induction on $M$ in all cases.
\end{proof}

\begin{note}
The familiar substitution lemma also holds as usual: $t [\vec{z_1} := \vec{s_1}] [\vec{z_2} := \vec{s_2}] \equiv t [\vec{z_1} := \vec{s_1}[\vec{z_2} := \vec{s_2}], 
\vec{z_2} := \vec{s_2}]$.  We cannot form a lemma about the fourth case, simplifying $M \{ \vec{x} := \vec{P} \} \{ \vec{y} := \vec{Q} \}$, because
$M \{ \vec{x} := \vec{P} \}$ is a path, and path substitution can only be applied to a term.
\end{note}

We introduce a notation for simultaneous substitution and path substitution of several variables:

\begin{definition}
A \emph{substitution} is a function that maps term variables to terms, proof variables to proofs, and path variables to paths.
We write $E[\sigma]$ for the result of substituting the expression $\sigma(z)$ for $z$ in $E$, for each variable $z$ in the domain of $\sigma$.

A \emph{path substitution} $\tau$ is a function whose domain is a finite set of term variables,
and which maps each term variable to a path.  Given a path substitution $\tau$ and substitutions $\rho$, $\sigma$
with the same domain $\{ x_1, \ldots, x_n \}$, we write
\[ M \{ \tau : \rho = \sigma \} \text{ for } M \{ x_1 := \tau(x_1) : \rho(x_1) = \sigma(x_1), \ldots, \tau(x_n) : \rho(x_n) = \sigma(x_n) \} \enspace . \]
\end{definition}

\subsubsection{Call-By-Need Reduction}

\begin{definition}[Call-By-Need Reduction]
Define the relation of \emph{call-by-need reduction} $\rightarrow$ on the expressions as follows:
$$ \infer{(\lambda x:A.M)N \rightarrow M[x:=N]}{} \quad
\infer{MN \rightarrow M'N}{M \rightarrow M'} \quad
\infer{\varphi \supset \psi \rightarrow \varphi' \supset \psi}{\varphi \rightarrow \varphi'} $$
$$ \infer{\varphi \supset \psi \rightarrow \varphi \supset \psi'}{\psi \rightarrow \psi'} \quad
\infer{(\lambda p : \varphi . \delta)\epsilon \rightarrow \delta [ p := \epsilon ]}{} \quad
\infer{\reff{\varphi}^+ \delta \rightarrow \delta}{} \quad
\infer{\reff{\varphi}^- \delta \rightarrow \delta}{} $$
$$ \infer{\univ{\varphi}{\psi}{\delta}{\epsilon}^+ \rightarrow \delta}{} \quad
\infer{\univ{\varphi}{\psi}{\delta}{\epsilon}^- \rightarrow \epsilon}{} \quad
\infer{\delta \epsilon \rightarrow \delta' \epsilon}{\delta \rightarrow \delta'} $$
$$ \infer{P^+ \rightarrow Q^+}{P \rightarrow Q} \quad
\infer{P^- \rightarrow Q^-}{P \rightarrow Q} \quad
\infer{(\triplelambda e:x =_A y.P)_{MN} Q \rightarrow P [x := M, y := N, e := Q]}{} $$
$$ \infer{\reff{\lambda x:A.M}_{N N'} P \rightarrow M \{ x:=P : N = N' \}}{} $$
$$ \infer{\reff{M} \rightarrow \reff{N}}{M \rightarrow N} \quad
\infer{P_{MN} Q \rightarrow P'_{MN} Q}{P \rightarrow P'} \quad
\infer{\reff{\varphi} \supset^* \reff{\psi} \rightarrow \reff{\varphi \supset \psi}}{} $$
$$ \infer{\reff{\varphi} \supset^* \univ{\psi}{\chi}{\delta}{\epsilon} \rightarrow 
\univ{\varphi \supset \psi}{\varphi \supset \chi}{\lambda p:\varphi \supset \psi. \lambda q : \varphi. \delta (pq)}{\lambda p : \varphi \supset \chi. \lambda q : \varphi. \epsilon (pq)}}{} $$
$$ \infer{\univ{\varphi}{\psi}{\delta}{\epsilon} \supset^* \reff{\chi} \rightarrow
\univ{\varphi \supset \chi}{\psi \supset \chi}{\lambda p : \varphi \supset \chi. \lambda q : \psi. p (\epsilon q)}{\lambda p:\psi \supset \chi. \lambda q : \varphi. p(\delta q)}}{} $$
$$ \infer{\begin{array}{l}
\univ{\varphi}{\psi}{\delta}{\epsilon} \supset^* \univ{\varphi'}{\psi'}{\delta'}{\epsilon'} \\
 \rightarrow
\univ{\varphi \supset \varphi'}{\psi \supset \psi'}{\lambda p : \varphi \supset \varphi'. \lambda q : \psi. \delta' (p(\epsilon q))}{\lambda p : \psi \supset \psi'. \lambda q : \varphi. \epsilon' (p (\delta q))}
\end{array}}{} $$
$$ \infer{P \supset^* Q \rightarrow P' \supset^* Q}{P \rightarrow P'} \quad
\infer{P \supset^* Q \rightarrow P \supset^* Q'}{Q \rightarrow Q'} $$
\end{definition}

\begin{lemma}[Diamond Property]
\label{lm:diamond}
If $E \rightarrow F$ and $E \rightarrow G$, then there exists $H$ such that $F \rightarrow H$ and $G \rightarrow H$.
\end{lemma}

\begin{proof}
This is easily proven by induction on the hypotheses.  The critical pairs are as follows: \textbf{TODO}
\end{proof}

\begin{lemma}[Reduction respects path substitution]
\label{lm:resp-sub}
If $M \rightarrow N$ then $M \{ \tau : \rho = \sigma \} \rightarrow N \{ \tau : \rho = \sigma \}$.
\end{lemma}

\begin{proof}
Induction on $M \rightarrow N$.  The only difficult case is $\beta$-contraction.  We have
\begin{align*}
& ((\lambda x:A.M)N)\{ \tau : \rho = \sigma \} \\
\equiv & (\triplelambda e : x =_A x' . M \{ \tau : \rho = \sigma, x := e : x = x' \})_{N [ \rho ] N [ \sigma ]} N \{ \tau : \rho = \sigma \} \\
\rightarrow & M \{ \tau : \rho = \sigma, x := N \{ \tau \} : N [ \rho ] = N [ \sigma ] \} \\
\equiv & M [ x := N ] \{ \tau : \rho = \sigma \} & (\text{Lemma \ref{lm:pathsubsub}})
\end{align*}
\end{proof}

We write $\twoheadrightarrow$ for the reflexive transitive closure of $\rightarrow$, and $\simeq$ for the reflexive symmetric transitive closure of $\rightarrow$.
We say an expression $E$ is in \emph{normal form} iff there is no expression $F$ such that $E \rightarrow F$.

\subsubsection{Canonicity}

\begin{definition}[Canonical Object]
$ $
\begin{itemize}
\item
The canonical objects $\theta$ of $\Omega$, or \emph{canonical propositions}, are given by the grammar
\[ \theta ::= \bot \mid \theta \supset \theta \]
\item
A canonical object of type $A \rightarrow B$ has the form $\lambda x:A.M$, where
$x : A \vdash M : B$.
\end{itemize}
We define the \emph{canonical proofs} of a canonical object $\theta$ of $\Omega$ as follows:
\begin{itemize}
\item
There is no canonical proof of $\bot$.
\item
A canonical proof of $\varphi \supset \psi$ has the form $\lambda p : \varphi . \delta$, where $p : \varphi \vdash \delta : \psi$.
\end{itemize}
We define the \emph{canonical paths} of an equation $M =_A N$, where $M$ and $N$ are canonical objects of $A$, as follows:
\begin{itemize}
\item
A canonical path of $\varphi =_\Omega \psi$ is either $\reff{\varphi}$ if $\varphi \simeq \psi$, or $\univ{\varphi}{\psi}{\delta}{\epsilon}$, where $\delta$ is a canonical
proof of $\varphi \supset \psi$ and $\epsilon$ is a canonical proof of $\psi \supset \varphi$.
\item
A canonical path of $F =_{A \rightarrow B} G$ is either $\reff{F}$ if $F \simeq G$, or $\triplelambda e:x =_A y.P$ where $x : A, y : A, e : x =_A y \vdash P : Fx =_B Gy$ and $P$ is in normal form.
\end{itemize}
\end{definition}

\begin{lemma}
\label{lm:compat-beta}
Suppose $\varphi$ reduces to a canonical proposition $\theta$, and $\varphi \simeq \psi$.  Then $\psi$ reduces to $\theta$.
\end{lemma}

\begin{proof}
This follows from the fact that $\rightarrow$ satisfies the diamond property, and every canonical proposition $\theta$ is a normal form.
\end{proof}

\subsubsection{Neutral Expressions}

\begin{definition}[Neutral]$ $
The \emph{neutral} terms, paths and proofs are given by the grammar
\[ \begin{array}{lrcl}
\text{Neutral term} & M_n & ::= & x \mid M_n N \\
\text{Neutral proof} & \delta_n & ::= & p \mid P_n^+ \mid P_n^- \mid \delta_n \epsilon \\
\text{Neutral path} & P_n & ::= & e \mid P_n \supset^* Q \mid Q \supset^* P_n \mid (P_n)_{MN} Q
\end{array} \]
\end{definition}

\begin{lemma}
A term in normal form is either a neutral term, a canonical proposition, or a $\lambda$-term.
\end{lemma}

\begin{proof}
An easy proof by case analysis.
\end{proof}

\subsection{Rules of Deduction}

The rules of deduction of PHOML are given in Figure \ref{fig:lambdaoe}.

\newcommand{\RvarT}{\ensuremath(\mathsf{varT})}
\begin{figure}
\paragraph*{Contexts}
\[ (\langle \rangle) \quad \vcenter{\infer{\langle \rangle \vald}{}} \qquad
(\mathrm{ctxt}_T) \quad \vcenter{\infer{\Gamma, x : A \vald}{\Gamma \vald}} \qquad 
(\mathrm{ctxt}_P) \quad \vcenter{\infer{\Gamma, p : \varphi \vald}{\Gamma \vdash \varphi : \Omega}} \]
\[ (\mathrm{ctxt}_E) \quad \vcenter{\infer{\Gamma, e : M =_A N \vald}{\Gamma \vdash M : A \quad \Gamma \vdash N : A}} \]
\[ (\mathrm{var}_T) \quad \vcenter{\infer[(x : A \in \Gamma)]{\Gamma \vdash x : A}{\Gamma \vald}} \qquad
(\mathrm{var}_P) \quad \vcenter{\infer[(p : \varphi \in \Gamma)]{\Gamma \vdash p : \varphi}{\Gamma \vald}} \]
\[ (\mathrm{var}_E) \quad \vcenter{\infer[(e : M =_A N \in \Gamma)]{\Gamma \vdash e : M =_A N}{\Gamma \vald}} \]

\paragraph*{Terms}
\[ (\bot) \quad \vcenter{\infer{\Gamma \vdash \bot : \Omega}{\Gamma \vald}} \qquad
(\supset) \quad \vcenter{\infer{\Gamma \vdash \varphi \supset \psi : \Omega}{\Gamma \vdash \varphi : \Omega \quad \Gamma \vdash \psi : \Omega}} \]
\[ (\mathrm{app}_T) \quad \vcenter{\infer{\Gamma \vdash M N : B} {\Gamma \vdash M : A \rightarrow B \quad \Gamma \vdash N : A}} \qquad
(\lambda_T) \quad \vcenter{\infer{\Gamma \vdash \lambda x:A.M : A \rightarrow B}{\Gamma, x : A \vdash M : B}} \]

\paragraph*{Proofs}
\[ (\mathrm{app}_P) \quad \vcenter{\infer{\Gamma \vdash \delta \epsilon : \psi} {\Gamma \vdash \delta : \varphi \supset \psi \quad \Gamma \vdash \epsilon : \varphi}} \qquad
(\lambda_P) \quad \vcenter{\infer{\Gamma \vdash \lambda p : \varphi . \delta : \varphi \supset \psi}{\Gamma, p : \varphi \vdash \delta : \psi}} \]
\[ (\mathrm{conv}_P) \quad \vcenter{\infer[(\varphi \simeq \psi)]{\Gamma \vdash \delta : \psi}{\Gamma \vdash \delta : \varphi \quad \Gamma \vdash \psi : \Omega}} \]

\paragraph*{Paths}
\[ (\mathrm{ref}) \quad \vcenter{\infer{\Gamma \vdash \reff{M} : M =_A M}{\Gamma \vdash M : A}}
\qquad
(\supset^*) \quad \vcenter{\infer{\Gamma \vdash P \supset^* Q : \varphi \supset \psi =_\Omega \varphi' \supset \psi'}{\Gamma \vdash P : \varphi =_\Omega \varphi' \quad \Gamma \vdash Q : \psi =_\Omega \psi'}} \]
\[ (\mathrm{univ}) \quad \vcenter{\infer{\Gamma \vdash \univ{\varphi}{\psi}{\delta}{\epsilon} : \varphi =_\Omega \psi}{\Gamma \vdash \delta : \varphi \supset \psi \quad \Gamma \vdash \epsilon : \psi \supset \varphi}} \]
\[ (\mathrm{plus}) \quad \vcenter{\infer{\Gamma \vdash P^+ : \varphi \supset \psi}{\Gamma \vdash P : \varphi =_\Omega \psi}}
\qquad
(\mathrm{minus}) \quad \vcenter{\infer{\Gamma \vdash P^- : \psi \supset \varphi}{\Gamma \vdash P : \psi =_\Omega \psi}} \]
\[ (\triplelambda) \quad \vcenter{\infer{\Gamma \vdash \triplelambda e : x =_A y . P : M =_{A \rightarrow B} N}
  {\begin{array}{c}
     \Gamma, x : A, y : A, e : x =_A y \vdash P : M x =_B N y \\
     \Gamma \vdash M : A \rightarrow B \quad
\Gamma \vdash N : A \rightarrow B
     \end{array}}} \]
\[ (\mathrm{app}_E) \quad \vcenter{\infer{\Gamma \vdash P_{NN'}Q : MN =_B M' N'}{\Gamma \vdash P : M =_{A \rightarrow B} M' \quad \Gamma \vdash Q : N =_A N' \quad \Gamma \vdash N : A \quad \Gamma \vdash N' : A}} \]
\[ (\mathrm{conv}_E) \quad \vcenter{\infer[(M \simeq M', N \simeq N')]{\Gamma \vdash P : M' =_A N'}{\Gamma \vdash P : M =_A N \quad \Gamma \vdash M' : A \quad \Gamma \vdash N' : A}} \]
\caption{Rules of Deduction of $\lambda oe$}
\label{fig:lambdaoe}
\end{figure}

\subsubsection{Metatheorems}

\label{section:meta}

In the lemmas that follow, the letter $\mathcal{J}$ stands for any of the expressions that may occur to the right of the turnstile in a judgement, i.e.~$\mathrm{valid}$, $M : A$, $\delta : \varphi$, or $P : M =_A N$.

\begin{lemma}[Context Validity]
Every derivation of $\Gamma, \Delta \vdash \mathcal{J}$ has a subderivation of $\Gamma \vald$.
\end{lemma}

\begin{proof}
Induction on derivations.
\end{proof}

\begin{lemma}[Weakening]
If $\Gamma \vdash \mathcal{J}$, $\Gamma \subseteq \Delta$ and $\Delta \vald$ then $\Delta \vdash \mathcal{J}$.
\end{lemma}

\begin{proof}
Induction on derivations.
\end{proof}

\begin{lemma}[Type Validity]
$ $
\begin{enumerate}
\item
If $\Gamma \vdash \delta : \varphi$ then $\Gamma \vdash \varphi : \Omega$.
\item
If $\Gamma \vdash P : M =_A N$ then $\Gamma \vdash M : A$ and $\Gamma \vdash N : A$.
\end{enumerate}
\end{lemma}

\begin{proof}
Induction on derivations.  The cases where $\delta$ or $P$ is a variable use Context Validity.
\end{proof}

\begin{lemma}[Generation]
$ $
\begin{enumerate}
\item
If $\Gamma \vdash x : A$ then $x : A \in \Gamma$.
\item
If $\Gamma \vdash \bot : A$ then $A \equiv \Omega$.
\item
If $\Gamma \vdash \varphi \supset \psi : A$ then $\Gamma \vdash \varphi : \Omega$, $\Gamma \vdash \psi : \Omega$ and $A \equiv \Omega$.
\item
If $\Gamma \vdash \lambda x:A.M : B$ then there exists $C$ such that $\Gamma, x : A \vdash M : C$ and $B \equiv A \rightarrow C$.
\item
If $\Gamma \vdash MN : A$ then there exists $B$ such that $\Gamma \vdash M : B \rightarrow A$ and $\Gamma \vdash N : B$.
\item
If $\Gamma \vdash p : \varphi$, then there exists $\psi$ such that $p : \psi \in \Gamma$ and $\varphi \simeq \psi$.
\item
If $\Gamma \vdash \lambda p:\varphi.\delta : \psi$, then there exists $\chi$ such that $\Gamma, p : \varphi \vdash \delta : \chi$ and $\psi \simeq \varphi \supset \chi$.
\item
If $\Gamma \vdash \delta \epsilon : \varphi$ then there exists $\psi$ such that $\Gamma \vdash \delta : \psi \supset \varphi$ and $\Gamma \vdash \epsilon : \psi$.
\item
If $\Gamma \vdash e : M =_A N$, then there exist $M'$, $N'$ such that $e : M' =_A N' \in \Gamma$ and $M \simeq M'$, $N \simeq N'$.
\item
If $\Gamma \vdash \reff{M} : N =_A P$, then we have $\Gamma \vdash M : A$ and $M \simeq N \simeq P$.
\item
If $\Gamma \vdash P \supset^* Q : \varphi =_A \psi$, then there exist $\varphi_1$, $\varphi_2$, $\psi_1$, $\psi_2$ such that
$\Gamma \vdash P : \varphi_1 =_\Omega \psi_1$, $\Gamma \vdash Q : \varphi_2 =_\Omega \psi_2$, $\varphi \simeq \varphi_1 \supset \psi_1$, $\psi \simeq \varphi_2 \supset \psi_2$, and $A \equiv \Omega$.
\item
If $\Gamma \vdash \univ{\varphi}{\psi}{P}{Q} : \chi =_A \theta$, then we have $\Gamma \vdash P : \varphi \supset \psi$, $\Gamma \vdash Q : \psi \supset \varphi$,
$\Gamma \vdash \chi \simeq_\Delta \varphi : \Omega$, $\Gamma \vdash \theta \simeq_\Delta \psi : \Omega$ and $A \equiv \Omega$.
\item
If $\Gamma \vdash \triplelambda e : x =_A y. P : M =_B N$ then there exists $C$ such that $\Gamma, x : A, y : A, e : x =_A y \vdash P : M x =_C N y$
and $B \equiv A \rightarrow C$.
\item
If $\Gamma \vdash P_{M M'} Q : N =_A N'$, then there exist $B$, $F$ and $G$ such that $\Gamma \vdash P : F =_{B \rightarrow A} G$, $\Gamma \vdash Q : M =_B M'$, $N \simeq F M$
and $N' \simeq G M'$.
\item
If $\Gamma \vdash P^+ : \varphi$, then there exist $\psi$, $\chi$ such that $\Gamma \vdash P : \psi =_\Omega \chi$ and $\varphi \simeq (\psi \supset \chi)$.
\item
If $\Gamma \vdash P^- : \varphi$, there exist $\psi$, $\chi$ such that $\Gamma \vdash P : \psi =_\Omega \chi$ and $\varphi \simeq (\chi \supset \psi)$.
\end{enumerate}
\end{lemma}

\begin{proof}
Induction on derivations.
\end{proof}

\begin{proposition}[Subject Reduction]
If $\Gamma \vdash s : T$ and $s \twoheadrightarrow t$ then $\Gamma \vdash t : T$.
\end{proposition}

\begin{proof}
It is sufficient to prove the case $s \rightarrow t$.  The proof is by a case analysis on $s \rightarrow t$, using the Generation Lemma.
\end{proof}

\subsubsection{Substitutions}

\begin{definition}
Let $\Gamma$ and $\Delta$ be contexts.  A \emph{substitution from $\Gamma$ to $\Delta$}\footnote{These have also been called \emph{context morphisms}, for example in Hoffman \cite{Hofmann97syntaxand}.  Note however that what we call a substitution from $\Gamma$ to $\Delta$ is what Hoffman calls a context morphism from $\Delta$ to $\Gamma$.}, $\sigma : \Gamma \Rightarrow \Delta$,
is a substitution whose domain is $\dom \Gamma$ such that:
\begin{itemize}
\item
for every term variable $x : A \in \Gamma$, we have $\Delta \vdash \sigma(x) : A$;
\item
for every proof variable $p : \varphi \in \Gamma$, we have $\Delta \vdash \sigma(p) : \varphi [ \sigma ]$;
\item
for every path variable $e : M =_A N \in \Gamma$, we have $\Delta \vdash \sigma(e) : M [ \sigma ] =_A N [ \sigma ]$.
\end{itemize}
\end{definition}

\begin{lemma}[Well-Typed Substitution]
If $\Gamma \vdash \mathcal{J}$, $\sigma : \Gamma \Rightarrow \Delta$ and $\Delta \vald$, then $\Delta \vdash \mathcal{J} [\sigma]$.
\end{lemma}

\begin{proof}
Induction on derivations.
\end{proof}

\begin{definition}
If $\rho, \sigma : \Gamma \rightarrow \Delta$ and $\tau$ is a path substitution whose domain
is the term variables in $\dom \Gamma$, then we write
$\tau : \sigma = \rho : \Gamma \rightarrow \Delta$ iff, for each variable $x : A \in \Gamma$, we have
$\Delta \vdash \tau(x) : \sigma(x) =_A \rho(x)$.
\end{definition}

\begin{lemma}[Path Substitution]
\label{lm:pathsub}
If $\tau : \sigma = \rho : \Gamma \rightarrow \Delta$ and $\Gamma \vdash M : A$ and $\Delta \vald$,
then $\Delta \vdash M \{ \tau : \sigma = \rho \} : M [ \sigma ] =_A M [ \rho ]$.
\end{lemma}

\begin{proof}
Induction on derivations.
\end{proof}

\section{Examples}

Using propositional extensionality, we can construct a path of type $\top = \top \rightarrow \top$, and thence a proof of $\top \rightarrow \top \rightarrow \top$.
But which of the canonical proofs of $\top \rightarrow \top \rightarrow \top$ have we constructed?


We define
\[ \top := \bot \rightarrow \bot, \quad I_\bot := \lambda p:\bot.p, \quad I_\Omega := \lambda x:\Omega.x, \quad F := \lambda x:\Omega.\top \rightarrow x, \quad H := \lambda h.h \top \enspace . \]

Now, we have
\begin{align*}
x : \Omega, y : \Omega, e : x =_\Omega y & \vdash \lambda p:\top \rightarrow x. e^+ (p I) & : & (\top \rightarrow x) \rightarrow y \\
x : \Omega, y : \Omega, e : x =_\Omega y & \vdash \lambda m : y. \lambda n : \top. e^- m & : & y \rightarrow \top \rightarrow x \\
x : \Omega, y : \Omega, e : x =_\Omega y & \vdash \univ*{\lambda p:\top \rightarrow x. e^- m}{\lambda m:y. \lambda n:\top. e^- m} & : & \top \rightarrow x =_\Omega y
\end{align*}

Let $P \equiv \univ*{\lambda p:\top \rightarrow x. e^+ (pI)}{\lambda m:y. \lambda n:\top. e^- m}$.  Then

\begin{align}
\therefore & \vdash \triplelambda e:x =_\Omega y. P & : & F =_{\Omega \rightarrow \Omega} I_\Omega \label{eq:llleP} \\
\therefore & \vdash (\reff{H})_{FI}(\triplelambda e:x =_\Omega y. P) & : & \top \rightarrow \top =_\Omega \top \label{eq:llleP2} \\
\therefore & \vdash ((\reff{H})_{FI}(\triplelambda e:x =_\Omega y.P))^- & : & \top \rightarrow \top \rightarrow \top \label{eq:llleP3}
\end{align}

And now we compute:

\begin{align*}
& ((\reff{H})_{FI}(\triplelambda e:x =_\Omega y.P))^- \\
\rightarrow & ((h \top) \{ h := \triplelambda e : x =_\Omega y.P : F = I \})^- \\
\equiv & ((\triplelambda e : x =_\Omega y.P)_{\top \top} (\reff{\top}))^- \\
\rightarrow & (P [ x := \top, y := \top, e := \reff{\top} ])^- \\
\equiv & \univ*{\lambda p : \top \rightarrow \top. \reff{\top}^+ (p I)}{\lambda m:\top. \lambda n:\top. \reff{\top}^- m}^- \\
\rightarrow & \lambda m : \top. \lambda n : \top. \reff{\top}^- m
\end{align*}

Therefore, given proofs $\delta, \epsilon : \top$, we have
\[ ((\reff{H})_{FI}(\triplelambda e:x =_\Omega y.P))^- \delta \epsilon \rightarrow \delta \enspace . \]

\subsection{Comparison with Cubical Type Theory}
\label{section:cubical}

In cubical type theory, we say that a type $A$ is a \emph{proposition} iff any two terms of type $A$ are propositionally equal; that is, there exists a path between any two terms of type $A$.  Let
\[ \isProp{A} \eqdef \Pi x,y:A. \Path{A}{x}{y} \]
and let $\Prop$ be the type of all types in $U$ that are propositions:
\[ \Prop \eqdef \Sigma X : U. \isProp{X} \enspace . \]
Let $\bot$ be any type in $U$ that is a proposition; that is, there exists a term of type $\isProp{\bot}$.  ($\bot$ may be the empty type, but we do not require this in what follows.)

Define
\[ \top := \bot \rightarrow \bot \]
Then there exists a term $\top_\Prop$ of type $\isProp{\top}$ (we omit the details).  Define
\[ I := \lambda X:\Prop.X.1, \quad F := \lambda X : \Prop.\top \rightarrow X.1, \quad H := \lambda h.h (\top , \top_\Prop) \]
Then we have
\[ \vdash \top : U \quad
\vdash I  : \Prop \rightarrow U \quad
\vdash F  : \Prop \rightarrow U \quad
\vdash H  : (\Prop \rightarrow U) \rightarrow U \]

From the fact that univalence is provable in cubical type theory \cite{cchm:cubical}, we can construct a term $Q$ such that
\[ \vdash Q : \Path{(\Prop \rightarrow U)}{I}{F} \enspace . \]
Hence we have
\[ \vdash \langle i \rangle H (Q i) : \Path{U}{HI}{HF} \]
which is definitionally equal to
\[ \vdash \langle i \rangle H (Q i) : \Path{U}{\top \rightarrow \top}{\top} \]
From this, we can apply transport to create a term of type $\top \rightarrow \top \rightarrow \top$.  Applying this to any terms $\delta, \epsilon : \top$ gives a term that
is definitionally equal to
\[ \mapid{\top}{\mapid{\top}{\delta}} \]
where $\mapid{}{}$ represents transport across the trivial path:
\[ \mapid{A}{t} \eqdef \comp^i \, A \, [] \, t \qquad (i \text{ does not occur in } A) \enspace . \]
(For the details of the calculation, see the appendix.)

This term does not compute any further, as we do not have $\mapid{A}{t} = t$ definitionally in cubical type theory.

\subsection{Provable Parametricity}
\label{section:exampletwo}

As discussed in the introduction, every function of type $\Omega \rightarrow \Omega$ that can be constructed in PHOML must respect logical equivalence.  This fact can actually be proved in PHOML,
in the following sense: there exists a proof $\delta$ of

\[ f : \Omega \rightarrow \Omega, x : \Omega, y : \Omega, p : x \supset y, q : y \supset x \vdash \delta : f x \supset f y \]

and a proof of $f y \supset f x$ in the same context.  Together, these can be read as a proof of 'if $f : \Omega \rightarrow \Omega$ and $x$ and $y$ are logically equivalent, then $fx$ and $fy$ are logically equivalent'.

Specifically, take
\[ \delta \eqdef (\reff{f}_{xy} \univ{x}{y}{p}{q})^+ \enspace . \]

Note that this is not possible in Martin-L\"{o}f Type Theory.

% TODO Thierry's comments - do this in cubical type theory
\section{Computable Expressions}

\begin{definition}[Computable Expression]
We define the relation $\models E : T$, read `$E$ is a computable expression of type $T$', as follows.
\begin{itemize}
\item
$\models M : A$ iff $\models M \{\} : M =_A M$.
\item
$\models \delta : \bot$ iff $\delta$ reduces to a neutral proof.
\item
For $\varphi$ and $\psi$ canonical propositions, $\models \delta : \varphi \supset \psi$ iff, for all $\epsilon$ such that $\models \epsilon : \varphi$, we have $\models \delta \epsilon : \psi$.
\item
If $\varphi$ reduces to the canonical proposition $\psi$, then $\models \delta : \varphi$ iff $\models \delta : \psi$.
\item
$\models P : \varphi =_\Omega \psi$ iff $\models P^+ : \varphi \supset \psi$ and $\models P^- : \psi \supset \varphi$.
\item
$\models P : M =_{A \rightarrow B} M'$ iff, for all $Q$, $N$, $N'$ such that $\models N : A$ and $\models N' : A$ and $\models Q : N =_A N'$, then we have $\models P_{NN'}Q : MN =_B M'N'$.
\end{itemize}
\end{definition}

\begin{definition}[Computable Substitution]
Let $\sigma$ be a substitution with domain $\dom \Gamma$.  We write $\models \sigma : \Gamma$ and say that
$\sigma$ is a \emph{computable} substitution on $\Gamma$ iff, for every entry $z : T$ in $\Gamma$, we have $\models \sigma(z) : T [ \sigma ]$.

We write $\models \tau : \rho = \sigma : \Gamma $, and say $\tau$ is a \emph{computable} path substitution between $\rho$ and $\sigma$, iff, for every term variable entry $x : A$ in $\Gamma$, we have $\models \tau(x) : \rho(x) =_A \sigma(x)$.
\end{definition}

\begin{lemma}[Conversion]
\label{lm:conv-compute}
If $\models E : S$ and $S \simeq T$ then $\models E : T$.
\end{lemma}

\begin{proof}
This follows easily from the definition and Lemma \ref{lm:compat-beta}.
\end{proof}

\begin{lemma}[Expansion]
\label{lm:expansion}
If $\models F : T$ and $E \rightarrow F$ then $\models E : T$.
\end{lemma}

\begin{proof}
An easy induction, using the fact that call-by-need reduction respects path substitution (Lemma \ref{lm:resp-sub}).
\end{proof}

\begin{lemma}[Reduction]
\label{lm:reduction}
If $\models E : T$ and $E \rightarrow F$ then $\models F : T$.
\end{lemma}

\begin{proof}
An easy induction, using the fact that call-by-need reduction is confluent (Lemma \ref{lm:diamond}).
\end{proof}

\begin{definition}
We introduce a closed term $c_A$ for every type $A$ such that $\models c_A : A$.
\begin{align*}
c_\Omega & \eqdef \bot \\
c_{A \rightarrow B} & \eqdef \lambda x:A.c_B
\end{align*}
\end{definition}

\begin{lemma}
$\models c_A : A$
\end{lemma}

\begin{proof}
An easy induction on $A$.
\end{proof}

\begin{lemma}
\label{lm:pre-ref-compute}
If $\models M : A \rightarrow B$ then $M$ reduces to a $\lambda$-expression.
\end{lemma}

\begin{proof}
Let $B \equiv B_1 \rightarrow \cdots \rightarrow B_n \rightarrow \Omega$ where $n \geq 0$.  We have that
\[ \models M \{\}_{c_Ac_A} c_A \{\}_{c_{B_1} c_{B_1}} c_{B_1} \{\} \cdots c_{B_n} \{\} : M c_{A} c_{B_1} \cdots c_{B_n} =_\Omega M c_{A} c_{B_1} \cdots c_{B_n} \]
and so $M c_A c_{B_1} \cdots c_{B_n}$ reduces to a canonical proposition.  This reduction must proceed by reducing to $M' c_A c_{B_1} \cdots c_{B_n}$ by reducing $M$,
then applying a $\beta$-reduction.  Therefore, $M$ reduces to a $\lambda$-expression
\end{proof}

\begin{lemma}
\label{lm:ref-compute-Omega}
For any term $\varphi$ that reduces to a canonical proposition, we have $\models \reff{\varphi} : \varphi =_\Omega \varphi$.
\end{lemma}

\begin{proof}
In fact we prove that, for any terms $M$ and $\varphi$ such that $\varphi$ reduces to a canonical proposition, we have
$\models \reff{M} : \varphi =_\Omega \varphi$.

It is sufficient to prove the case where $\varphi$ is a canonical proposition.
We must show that $\models \reff{M}^+ : \varphi \supset \varphi$ and $\models \reff{M}^- : \varphi \supset \varphi$.  So let $\models \delta : \varphi$.
Then $\models \reff{M}^+ \delta : \varphi$ and $\models \reff{M}^- \delta : \varphi$ by Expansion (Lemma \ref{lm:expansion}), as required.
\end{proof}

\begin{lemma}
$\models \varphi : \Omega$ if and only if $\varphi$ reduces to a canonical proposition.
\end{lemma}

\begin{proof}
If $\models \varphi : \Omega$ then $\models \varphi \{\}^+ : \varphi \supset \varphi$.  Therefore $\varphi \supset \varphi$ reduces to a canonical proposition,
and so $\varphi$ must reduce to a canonical proposition.

Conversely, suppose $\varphi$ reduces to a canonical proposition $\theta$.  We have $\varphi \{\} \twoheadrightarrow \theta \{\} \twoheadrightarrow \reff{\theta}$, and so $\models \varphi \{\} : \varphi =_\Omega \varphi$ by Expansion (Lemma \ref{lm:expansion}).  Hence $\models \varphi : \Omega$.
\end{proof}

\begin{lemma}
\label{lm:neutral-proof}
If $\delta$ is a neutral proof and $\varphi$ reduces to a canonical proposition, then $\models \delta : \varphi$.
\end{lemma}

\begin{proof}
It is sufficient to prove the case where $\varphi$ is a canonical proposition.  The proof is by induction on $\varphi$.

If $\varphi \equiv \bot$, then $\models \delta : \bot$ immediately from the definition.

If $\varphi \equiv \psi \supset \chi$, then let $\models \epsilon : \psi$.  We have that $\delta \epsilon$ is neutral,
hence $\models \delta \epsilon : \chi$ by the induction hypothesis.
\end{proof}

\begin{lemma}
\label{lm:neutral-path}
Let $\models M : A$ and $\models N : A$.  If $P$ is a neutral path, then $\models P : M =_A N$.
\end{lemma}

\begin{proof}
The proof is by induction on $A$.

For $A \equiv \Omega$: we have that $P^+$ and $P^-$ are neutral proofs, and $M$ and $N$ head reduce to canonical propositions, so $\models P^+ : M \supset N$ and
$\models P^- : N \supset M$ by the previous lemma, as required.

For $A \equiv B \rightarrow C$: let $\models L : B$, $\models L' : B$ and $\models Q : L =_B L'$.  Then we have $\models ML : C$, $\models NL' : C$ and
$P_{LL'} Q$ is a neutral path, hence $\models P_{L L'} Q : ML =_C NL'$ by the induction hypothesis, as required.
\end{proof}

\begin{lemma}
\label{lm:ref-compute}
If $\models M : A$ then $\models \reff{M} : M =_A M$.
\end{lemma}

\begin{proof}
If $A \equiv \Omega$, this is just Lemma \ref{lm:ref-compute-Omega}.

So suppose $A \equiv B \rightarrow C$.  Using Lemma \ref{lm:pre-ref-compute}, Reduction (Lemma \ref{lm:reduction}) and Expansion (Lemma \ref{lm:expansion}),
we may assume that $M$ is a $\lambda$-term.  Let $M \equiv \lambda y:D.N$.

Let $\models L : B$ and $\models L' : B$ and $\models P : L =_B L'$.  We must show that
\[ \models \reff{\lambda y:D.N}_{L L'} P : (\lambda y:D.N)L =_C (\lambda y:D.N)L' \enspace . \]
By Expansion and Conversion, it is sufficient to prove
\[ \models N \{ y := P : L = L' \} : N [ y:= L ] =_C N [y := L'] \enspace . \]
We have that $\models (\lambda y:D.N)\{\} : \lambda y:D.N =_{B \rightarrow C} \lambda y:D.N$, and so
\[ \models (\triplelambda e : y =_D y' . N \{ y := e : y = y' \})_{L L'} P : (\lambda y:D.N)L =_C (\lambda y:D.N)L' \enspace , \]
and the result follows by Reduction and Conversion.
\end{proof}

\begin{lemma}
\label{lm:compute-supset*}
If $\models P : \varphi =_\Omega \varphi'$ and $\models Q : \psi =_\Omega \psi'$ then $\models P \supset^* Q : \varphi \supset \psi =_\Omega \varphi' \supset \psi'$.
\end{lemma}

\begin{proof}
%Extract as lemma
By Reduction (Lemma \ref{lm:reduction}) and Expansion (Lemma \ref{lm:expansion}), we may assume that $P$ and $Q$ are normal forms.  We also have that $\varphi'$ reduces to a canonical proposition
$\theta_1 \supset \cdots \supset \theta_n \supset \bot$, say, and $P^+ p q_1 \cdots q_n$ reduces to a neutral proof.  Therefore, $P$ must be either a neutral path or have the form $\reff{-}$ or
$\univ*{-}{-}$.

If either $P$ or $Q$ is neutral then $P \supset^* Q$ is neutral, and the result follows from Lemma \ref{lm:neutral-path}.

Otherwise, let $\models \delta : \varphi \supset \psi$ and $\epsilon \models \varphi'$.  We must show that $\models (P \supset^* Q)^+ \delta \epsilon : \psi'$.

If $P \equiv \reff{M}$ and $Q \equiv \reff{N}$, then we have
\[ (P \supset^* Q)^+ \delta \epsilon \rightarrow \reff{M \supset N}^+ \delta \epsilon \rightarrow \delta \epsilon \enspace . \]
Now, $\models P^- \epsilon : \varphi$, hence $\models \epsilon : \varphi$ by Reduction, and so $\models \delta \epsilon : \psi$.  Therefore, $\models Q^+ (\delta \epsilon) : \psi'$,
and hence by Reduction $\models \delta \epsilon : \psi'$ as required.

If $P \equiv \reff{M}$ and $Q \equiv \univ{N}{N'}{\chi}{\chi'}$, then we have
\begin{align*}
(P \supset^* Q)^+ \delta \epsilon & \rightarrow \univ{M \supset N}{M \supset N'}{\lambda pq.\chi(pq)}{\lambda pq.\chi'(pq)}^+ \delta \epsilon \\
& \rightarrow (\lambda pq.\chi(pq)) \delta \epsilon
& \twoheadrightarrow \chi (\delta \epsilon)
\end{align*}
We have $\models P^- \epsilon : \varphi$, hence $\models \epsilon : \varphi$ by Reduction, and so $\models \delta \epsilon : \psi$.  Therefore,
$\models Q^+ (\delta \epsilon) : \psi'$, and hence by Reduction $\models \chi (\delta \epsilon) : \psi'$ as required.

The other two cases are similar.
\end{proof}

\begin{lemma}
\label{lm:univ-compute}
If $\models \delta : \phi \supset \psi$ and $\models \epsilon : \psi \supset \phi$ then $\models \univ{\phi}{\psi}{\delta}{\epsilon} : \phi =_\Omega \psi$.
\end{lemma}

\begin{proof}
We must show that $\models \univ{\phi}{\psi}{\delta}{\epsilon}^+ : \phi \supset \psi$ and $\models \univ{\phi}{\psi}{\delta}{\epsilon}^- : \psi \supset \phi$.
These follow from the hypotheses, using Expansion (Lemma \ref{lm:expansion}).
\end{proof}

\section{Proof of Canonicity}

\begin{theorem}
\begin{enumerate}
\item
If $\Gamma \vdash \mathcal{J}$ and $\models \sigma : \Gamma$, then $\models \mathcal{J} [ \sigma ]$.
\item
If $\Gamma \vdash M : A$ and $\models \tau : \rho = \sigma : \Gamma$, then $\models M \{ \tau : \rho = \sigma \} : M [ \rho ] =_A M [ \sigma ]$.
\end{enumerate}
\end{theorem}

\begin{proof}
The proof is by induction on derivations.
\begin{enumerate}
\item
For the (var) rules, the result is immediate from the hypothesis.  

The case ($\bot$) follows from Lemma \ref{lm:ref-compute-Omega}.

For the rule ($\supset$), we use Lemma \ref{lm:compute-supset*}.

The case (app$_T$) is trivial.

For the rule ($\lambda_T$), we must show that
\[ \Delta \models \lambda x:A.M[\sigma] : A \rightarrow B \enspace . \]
So let $\Delta \models N : A$.  Then the induction hypothesis gives
\[ \Delta \models M[\sigma, x:=N] : B \]
and so by Expansion (Lemma \ref{lm:expansion}) we have
\[ \Delta \models (\lambda x:A.M[\sigma])N : B \]
as required.

The case (app$_P$) is trivial.

The case ($\lambda_P$) is similar to ($\lambda_T$), also making use of Lemma \ref{lm:conv-compute}.

The case (conv$_P$) follows immediately from Lemma \ref{lm:conv-compute}.

The case (ref) is immediate from Lemma \ref{lm:ref-compute}.  The case (univ) is immediate from Lemma \ref{lm:univ-compute}.

The cases (plus) and (minus) are trivial.

For the rule ($\triplelambda$), let $\Delta \models Q : L =_A L'$.  Then the induction hypothesis gives
\[ \Delta \models P [ \sigma, x := L, y := L', e := Q ] : M [\sigma] L =_B N [\sigma] L' \]
and hence Expansion gives
\[ \Delta \models (\triplelambda e:x =_A y.P [ \sigma ])_{L L'} Q : M[\sigma] L =_B N[\sigma] L' \]
as required.

The case (app$_E$) is trivial.  The case (conv$_E$) follows immediately from Lemma \ref{lm:conv-compute}.
\item
The case (var$_T$) is immediate from hypothesis.

The case ($\bot$) follows from Lemma \ref{lm:ref-compute-Omega}.

The case ($\supset$) follows from Lemma \ref{lm:compute-supset*}.

The case (app$_T$) is trivial.

For the case ($\lambda$), we must show that
\[ \Delta \models \triplelambda e : x =_A y. M \{ \tau : \rho = \sigma, x := e : x = y \} : \lambda x:A.M [ \rho ] =_{A \rightarrow B} \lambda x:A.M [ \sigma ] \enspace . \]
So let $\Delta \models P : N =_A N'$.  The induction hypothesis gives
\[ \Delta \models M \{ \tau : \rho = \sigma, x := P : N = N' \} : M [\rho, x := N] =_B M [\sigma, x := N'] \enspace , \]
and so we have
\[ \Delta \models (\triplelambda e : x =_A y. M \{ \tau : \rho = \sigma, x := e : x = y \})_{N N'} P : (\lambda x:A.M [ \rho ])N =_B (\lambda x:A.M [ \sigma ])N'\]
by Expansion, as required.
\end{enumerate}
\end{proof}

\begin{corollary}
If $\Gamma \vdash E : T$ then $E$ reduces to a normal form.
\end{corollary}

\begin{proof}
Let $\mathrm{id}_\Gamma$ be the substitution on $\dom \Gamma$ that maps a variable to itself.
We prove that, if $\Gamma \vald$, then $\models \mathrm{id}_\Gamma : \Gamma$; the proof is by induction on derivations, and uses Lemmas \ref{lm:neutral-proof} and \ref{lm:neutral-path}.
\end{proof}

\begin{corollary}[Canonicity]
If $\vdash E : T$ then $E$ reduces to a canonical form.
\end{corollary}

\begin{corollary}[Consistency]
There is no proof $\delta$ such that $\vdash \delta : \bot$.
\end{corollary}

\section{Conclusion}

We have presented a system with propositional extensionality, and shown that it satisfies the property of canonicity.
We now intend to do the same for stronger and stronger systems, getting
ever closer to full homotopy type theory.  The next steps will be:

\begin{itemize}
\item
a system where the equations $M =_A N$ are objects of $\Omega$, allowing us to form propositions such as $M =_A N \supset N =_A M$.
\item
a system with universal quantification over the types $A$, allowing us to form propositions such as $\forall x:A. x =_A x$ and
$\forall x,y : A. x =_A y \supset y =_A x$
\end{itemize}

\bibliography{../../../../type}

\appendix

\section{Calculation in Cubical Type Theory}
\label{appendix:cubical}

\newcommand{\steptwo}{\mathrm{step}_2}
\newcommand{\stepthree}{\mathrm{step}_3}

%TODO Better name than step2 and step3
We can prove that, if $X$ is a proposition, then the type $\Sigma f:\top \rightarrow X. Path \, X \, x \, (f I)$ is contractible (we omit the details).  Let $e[X, x, p]$ be the term such that
\begin{align*} & X : \Prop, x : X.1, p : \Sigma f:\top \rightarrow X.1. \Path{X.1}{x}{(fI)} \\
\vdash & e[X, x, p] : \Path{(\Sigma f:\top \rightarrow X.1. \Path{X.1}{x}{(f I)})}{\langle \lambda t : \top . x, 1_{X.1} \rangle}{p}
\end{align*}

Let $\steptwo [X,x] \eqdef \langle \langle \lambda t : T.x, 1_{X.1} \rangle,
\lambda p : \Sigma f : T \rightarrow X.1. \Path{X.1}{x}{(fI)}. e[X, x, p] \rangle$.  Then
$$ X : \Prop, x : X.1 \vdash \steptwo [X, x] : \mathsf{isContr}(\Sigma f:T \rightarrow X.1. \Path{X.1}{x}{(fI)}) \enspace . $$
Let $\stepthree [X] \equiv \lambda x : X.1. step2[X, x]$.  Then
$$ X : \Prop \vdash \stepthree [X] : \mathsf{isEquiv} \, (T \rightarrow X.1) \, X.1 \, (\lambda f : T \rightarrow X.1. f I) \enspace . $$
Let $E[X] \equiv \langle \lambda f : \top \rightarrow X.1. f I, step3[X] \rangle$.  Then
$$ X : \Prop \vdash E[X] : Equiv \, (\top \rightarrow X.1) \, X.1 $$

From this equivalence, we want to get a path from $\top \rightarrow X.1$ to $X.1$ in $U$.  We apply the proof of univalence in \cite{cchm:cubical}

Let $P[X] \equiv \langle i \rangle \mathsf{Glue} [(i = 0) \mapsto (\top \rightarrow X.1, E[X]), (i = 1) \mapsto (X.1, equiv^k X.1)] X.1$.  Then
$$ X : \Prop \vdash P[X] : \Path{U}{(\top \rightarrow X.1)}{X.1} $$
Let $Q \equiv \langle i \rangle \lambda x : \Prop. P[X] i$.  Then
$$ \vdash Q : \Path{(\Prop \rightarrow U)}{F}{I} $$

This is the term in cubical type theory that corresponds to $\triplelambda e : x =_\Omega y.P$ in HOML (formula \ref{eq:llleP}).  We now construct
terms corresponding to formulas (\ref{eq:llleP2}) and (\ref{eq:llleP3}):
\[ \vdash \langle i \rangle H (Q i) : \Path{U}{(\top \rightarrow \top)}{\top} \]
\[ \vdash \lambda x : \top. \comp^i (H (Q (1 - i))) [] x : \top \rightarrow \top \rightarrow \top \]

Let us write $\outputt$ for this term:
\[ \outputt \eqdef \lambda x : \top. \comp^i (H (Q (1 - i))) [] x \enspace . \]
And we calculate (using the notation from \cite{cchm:cubical} section 6.2):
\begin{align*}
\outputt
& = \lambda x : \top. \comp^i (Q (1 - i) \top) [] x \\
& = \lambda x : \top. \comp^i (P[\top] (1 - i)) [] x \\
& = \lambda x : \top. \comp^i (\mathsf{Glue}[(i = 1) \mapsto (\top \rightarrow \top, E[\top]), (i = 0) \mapsto (\top, equiv^k \top)] \top) [] x \\
& = \lambda x : \top. \mathsf{glue} [ 1_\mathbb{F} \mapsto t_1 ] a_1 \\
& = \lambda x : \top. t_1 \\
& = \lambda x : \top. (\mathsf{equiv} \, E[\top] \, [] \, mapid_\top(x)).1 \\
& = \lambda x : \top. (\mathsf{contr} (step2[\top, mapid_\top(x)]) []).1 \\
& = \lambda x : \top. (\comp^i (\Sigma f : \top \rightarrow \top. \Path{\top}{mapid_\top(x)}{(fI)}) [] \langle \lambda t : \top. mapid_\top(x), 1_{mapid_\top(x)} \rangle).1 \\
& = \lambda x : \top. \mapid{\top \rightarrow \top}{\lambda _ : \top. \mapid{\top}{x}} \\
\therefore \outputt \, m \, n & = \mapid{\top \rightarrow \top}{\lambda _ : \top. \mapid{\top}{m}} n \\
& \equiv (\comp^i (\top \rightarrow \top) [] (\lambda _ : \top. \mapid{\top}{m})) n \\
& = \mapid{\top}{\mapid{\top}{m}}
\end{align*}
\end{document}
