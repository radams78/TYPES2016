\AgdaHide{
\begin{code}
module PHOPL.Computable.Base where
open import Data.Unit
open import Data.Product renaming (_,_ to _,p_) hiding (zip)
open import Prelims.HetList
open import PHOPL.Grammar
open import PHOPL.Red
open import PHOPL.Rules
open import PHOPL.PathSub
open import PHOPL.Computable.Meaning
\end{code}
}

\newcommand{\ldot}{\, . \,}
\begin{definition}[Computable Expressions]
\label{df:computable}
\begin{align*}
E_\Gamma(\chi) \eqdef \{ \delta \mid & \Gamma \vdash \delta : \chi\text{ and } \delta \in \SN \} \\
& \qquad (\chi \text{ is neutral or } \bot) \\
E_\Gamma(\phi \supset \psi) \eqdef \{ \delta \mid & \Gamma \vdash \delta : \phi \supset \psi\text{ and } \\
& \forall \Delta \supseteq \Gamma \ldot \forall \epsilon \in E_\Delta(\phi)\ldot \delta \epsilon \in E_\Gamma(\psi) \} \\
& \qquad (\phi , \psi \text{ normal forms}) \\
E_\Gamma(\phi) \eqdef \{ \delta \mid & \Gamma \vdash \delta : \phi\text{ and } \delta \in \SN \} \\
& \qquad (\phi \text{ neutral}) \\
E_\Gamma(\phi) \eqdef \{ \delta \mid & \Gamma \vdash \delta : \phi\text{ and } \delta \in E_\Gamma(\nf{\phi}) \} \\
& \qquad (\phi \text{ a weakly normalizable term}) \\
\\
E_\Gamma(\Omega) \eqdef \{ M \mid & \Gamma \vdash M : \Omega\text{ and } M \in \SN\text{ and } \\
& M \{\} \in E_\Gamma(M =_\Omega M) \} \\
E_\Gamma(A \rightarrow B) \eqdef \{ M \mid & \Gamma \vdash M : A \rightarrow B\text{ and } \\
& \forall \Delta \supseteq \Gamma\ldot \forall N \in E_\Delta(A)\ldot MN \in E_\Delta(B)\text{ and } \\
& M \{\} \in E_\Gamma(M =_{A \rightarrow B} M) \} \\
\\
E_\Gamma(\phi =_\Omega \psi) \eqdef \{ P \mid & \Gamma \vdash P : \phi =_\Omega \psi\text{ and } \\
& P^+ \in E_\Gamma(\phi \supset \psi)\text{ and } P^- \in E_\Gamma(\psi \supset \phi) \} \\
& \qquad (\phi , \psi \text{ weakly normalizable terms}) \\
\\
E_\Gamma(M =_{A \rightarrow B} M') \eqdef \{ P \mid & \Gamma \vdash P : M =_{A \rightarrow B} M'\text{ and } \\
& \forall \Delta \supseteq \Gamma\ldot \forall N, N' \in E_\Delta(A)\ldot \forall Q \in E_\Delta(N =_A N')\ldot \\
& P_{NN'}Q \in E_\Delta(MN =_B M'N') \}
\end{align*}
\end{definition}

If $\phi$ is a term that is not m-normalizable, then $E_\Gamma(\phi)$ is undefined.  Similarly, $E_\Gamma(\phi =_\Omega \psi)$ is undefined if $\phi$ and $\psi$ are
not both m-normalizable.

The Agda code for this definition is shown in Figure \ref{fig:compute}

\begin{figure}
\begin{code}
computeP : ∀ {V S} → Context V → Meaning V S → Proof V → Set
computeP Γ (nf₀ _) δ = SN δ
computeP Γ (φ imp ψ) δ = 
  ∀ {W} (Δ : Context W) {ρ} {ε}
  (ρ∶Γ⇒RΔ : ρ ∶ Γ ⇒R Δ) (Δ⊢ε∶φ : Δ ⊢ ε ∶ (decode-Meaning (nfrep φ ρ)))
  (computeε : computeP Δ (nfrep φ ρ) ε) → 
  computeP Δ (nfrep ψ ρ) (appP (δ 〈 ρ 〉) ε)

computeT : ∀ {V} → Context V → Type → Term V → Set
computeE : ∀ {V} → Context V → Term V → Type → Term V → Path V → Set

computeT Γ Ω M = SN M
computeT Γ (A ⇛ B) M = 
  (∀ {W} (Δ : Context W) {ρ} {N} (ρ∶Γ⇒Δ : ρ ∶ Γ ⇒R Δ) (Δ⊢N∶A : Δ ⊢ N ∶ ty A) (computeN : computeT Δ A N) →
    computeT Δ B (appT (M 〈 ρ 〉) N)) ×
  (∀ {W} (Δ : Context W) {ρ} {N} {N'} {P} 
    (ρ∶Γ⇒Δ : ρ ∶ Γ ⇒R Δ) (Δ⊢P∶N≡N' : Δ ⊢ P ∶ N ≡〈 A 〉 N') 
    (computeN : computeT Δ A N) (computeN' : computeT Δ A N') (computeP : computeE Δ N A N' P) →
    computeE Δ (appT (M 〈 ρ 〉) N) B (appT (M 〈 ρ 〉) N') (M 〈 ρ 〉 ⋆[ P ∶ N ∼ N' ]))

computeE {V} Γ M Ω N P = Σ[ S ∈ MeaningShape ] Σ[ φ ∈ Meaning V S ] Σ[ ψ ∈ Meaning V S ] M ↠ decode-Meaning φ × N ↠ decode-Meaning ψ × computeP Γ (φ imp ψ) (plus P) × computeP Γ (ψ imp φ) (minus P)
computeE Γ M (A ⇛ B) M' P =
  ∀ {W} (Δ : Context W) {ρ} {N} {N'} {Q} (ρ∶Γ⇒RΔ : ρ ∶ Γ ⇒R Δ) (Δ⊢Q∶N≡N' : Δ ⊢ Q ∶ N ≡〈 A 〉 N')
  (computeN : computeT Δ A N) (computeN' : computeT Δ A N') (computeQ : computeE Δ N A N' Q) → computeE Δ (appT (M 〈 ρ 〉) N) B (appT (M' 〈 ρ 〉)  N') 
    (app* N N' (P 〈 ρ 〉) Q)

EdefE : ∀ {V} → Context V → Type → Term V → Term V → Set
Edef : ∀ {V K} → Context V → Expression V (parent K) → Set
compute : ∀ {V} {K} (Γ : Context V) (A : Expression V (parent K)) → Edef {V} {K} Γ A → 
  Expression V (varKind K) → Set
E : ∀ {V K} Γ A (Adef : Edef {V} {K = K} Γ A) (M : Expression V (varKind K)) → Set

Edef {K = -Proof} Γ φ = MeanTerm φ 
Edef {K = -Term} Γ A = ⊤
Edef {K = -Path} Γ (app (-eq A) (M ∷ N ∷ [])) = EdefE Γ A M N

EdefE Γ Ω φ ψ = MeanTerm φ × MeanTerm ψ
EdefE Γ (A ⇛ B) F G = ∀ {W} (Δ : Context W) {ρ} {N} {N'} {Q} (N≡N' : EdefE Δ A N N') →
    ρ ∶ Γ ⇒R Δ → E {W} {K = -Term} Δ (ty A) tt N → E Δ (ty A) tt N' → 
    E {W} { -Path} Δ (N ≡〈 A 〉 N') N≡N' Q →
    EdefE Δ B (appT (F 〈 ρ 〉) N) (appT (G 〈 ρ 〉) N')

compute {K = -Proof} Γ φ (MeanTermI .nf₀ (nf₀ x) red) δ = SN δ
compute {K = -Proof} Γ _ (MeanTermI _ (φ imp ψ) red) δ = 
  {!∀ {W} (Δ : Context W) {ρ} {ε} →
    ρ ∶ Γ ⇒R Δ → E Δ (decode-Meaning φ 〈 ρ 〉) ? ε →
    E Δ (decode-Meaning ψ 〈 ρ 〉) (appP (δ 〈 ρ 〉) ε)
    !}
compute {K = -Term} Γ A Adef M = {!!}
compute {K = -Path} Γ A Adef M = {!!}
E {V} {K} Γ A Adef M = {!!}

{-data Edef where
  EdefTI : ∀ {V Γ A} → Edef {K = -Term} Γ (ty A)
  EdefPI : ∀ {V Γ φ} → MeanTerm φ → Edef {K = -Proof} Γ φ
  EdefEΩI : ∀ {V Γ φ ψ} → MeanTerm φ → MeanTerm ψ → Edef {K = -Path} Γ (φ ≡〈 Ω 〉 ψ)
  EdefE⇛I : ∀ {V Γ F G A B} → 
    (∀ {W} (Δ : Context W) {ρ} {N} {N'} {Q} (N≡Ndef : Edef Δ (N ≡〈 A 〉 N')) →
      ρ ∶ Γ ⇒R Δ → E Δ (ty A) EdefTI N → E Δ (ty A) EdefTI N' → E Δ (N ≡〈 A 〉 N') N≡Ndef Q → 
      Edef Δ (appT (F 〈 ρ 〉) N ≡〈 B 〉 appT (G 〈 ρ 〉) N')) →
    Edef Γ (F ≡〈 A ⇛ B 〉 G)

compute {K = -Term} Γ (app (-ty A) out) _ M = computeT Γ A M
compute {K = -Proof} Γ φ φdef δ = ?
--computeP Γ (MeanTerm.meaning φmean) δ
compute {K = -Path} Γ (app (-eq Ω) (φ ∷ ψ ∷ [])) φ≡ψdef P = ?
--  computeP Γ (MeanTerm.meaning φmean imp MeanTerm.meaning ψmean) (plus P) ×
--  computeP Γ (MeanTerm.meaning ψmean imp MeanTerm.meaning φmean) (minus P)
compute {K = -Path} Γ (app (-eq (A ⇛ B)) (F ∷ G ∷ [])) F≡Gdef P = ?
--  ∀ {W} (Δ : Context W) {ρ} {N} {N'} {Q} (ρ∶Γ⇒RΔ : ρ ∶ Γ ⇒R Δ)
--    (EN : E Δ A N) (EN' : E Δ A N') (EQ : E Δ A (N ≡〈 A 〉 N')) →
--    compute Δ (appT (F 〈 ρ 〉) N ≡〈 B 〉 appT (G 〈 ρ 〉) N') (F≡Gdef Δ ρ∶Γ⇒RΔ EN EN' EQ)
--      (app* N N' (P 〈 ρ 〉) Q)

data E {V} {K} Γ A Adef M where
  EI : Γ ⊢ M ∶ A → compute Γ A Adef M → E Γ A Adef M -}

--allE : ∀ {V} (Γ : Context V) {SS} → ListMeaning V SS → K MeaningShape (Proof V) SS → Set
--allE {V} Γ {SS} φφ pp = all (λ {φ} → λ {(φ ,p δ) → E Γ (decode-Meaning φ) δ}) SS (zip φφ pp)
\end{code}
\caption{Agda definition of the computable expressions}
\label{fig:compute}
\end{figure}

